# Backend Structure Document

This document outlines the foundational backend system for the Universal Token Launcher. It details the database architecture, authentication and authorization, file storage, API design, data security, and strategies for scalability and modularity.

---

## 1. Database Architecture

We use **PostgreSQL** as our primary relational database, managed via **SQLAlchemy ORM** and **Alembic** for migrations. Data is normalized to avoid redundancy, with separate tables for token and NFT deployments.

### 1.1. Token Deployments Table (`token_deployments`)
*Purpose:* Record each token deployment configuration and status across multiple chains.
- **Key Fields:**
  - `id` (SERIAL, PRIMARY KEY)
  - `token_name`, `token_symbol`, `decimals`, `total_supply` (Token metadata)
  - `zc_contract_address` (STRING, nullable) – The primary ZetaChain contract address.
  - `deployer_address` (STRING, NOT NULL) – The wallet address of the token creator (receives ownership).
  - `connected_chains_json` (JSONB, NOT NULL, default {}) – Stores per-chain deployment data including: contract address, transaction hash, deployment status, verification status, explorer URLs, etc. *(See schema definition in `app/models/token.py` for exact structure)*.
  - `deployment_status` (VARCHAR, NOT NULL, default 'starting') – Overall status (starting, deploying, connecting, distributing, completed, failed).
  - `verification_status` (VARCHAR, nullable) – Verification status *specifically for the ZetaChain contract* (pending, verified, failed).
  - `error_message` (TEXT, nullable) – Stores error messages from deployment or verification failures.
  - `created_at`, `updated_at` (TIMESTAMPS)
- **Indexes:** Indexes are placed on `deployer_address`, `zc_contract_address`, and potentially within the `connected_chains_json` field for efficient lookups.

### 1.2. NFT Deployments Table (`nft_deployments`)
*Purpose:* Record each NFT collection deployment configuration and status.
- **Key Fields:** (Similar structure to `token_deployments`, but specific to NFTs)
  - `id` (SERIAL, PRIMARY KEY)
  - `collection_name`, `collection_symbol`, `base_uri`, `max_supply` (NFT metadata)
  - `zc_contract_address` (STRING, nullable)
  - `deployer_address` (STRING, NOT NULL)
  - `connected_chains_json` (JSONB, NOT NULL, default {}) - Per-chain NFT contract details.
  - `deployment_status` (VARCHAR)
  - `verification_status` (VARCHAR, nullable) - ZetaChain NFT contract verification status.
  - `error_message` (TEXT, nullable)
  - `created_at`, `updated_at` (TIMESTAMPS)

*(Refer to `app/models/` for the precise SQLAlchemy model definitions and Pydantic schemas.)*

### 1.3. Verification Status Management

Verification status is tracked at two levels:
1.  **ZetaChain Contract:** The top-level `verification_status` column in the respective deployment table tracks the primary ZetaChain contract's verification (pending, verified, failed).
2.  **EVM Contracts:** Verification status for each connected EVM chain contract is stored within the `connected_chains_json` field for that specific chain entry.

This allows for granular tracking and reporting of verification progress across all deployed contracts.

---

## 2. Authentication & Authorization

- **Method:** Primarily relies on the `X-Wallet-Address` header for identifying the user making the request. *Note: The current implementation may bypass actual signature verification in debug mode (controlled by `.env` settings). Production deployments should enforce stricter signature-based verification.*
- **Session Management:** No server-side sessions or JWTs are currently implemented. Authorization is based on matching the `X-Wallet-Address` header with the `deployer_address` stored for a given token/NFT deployment for modification or status-check endpoints.
- **Roles & Permissions:** Implicit roles based on actions:
  - **Creator/Deployer:** The address that initiates a deployment.
  - **Service Account:** The backend uses a `DEPLOYER_PRIVATE_KEY` from `.env` to perform all on-chain actions (deployment, linking, ownership transfer).

---

## 3. Storage Buckets / File Handling

*(Note: File handling for icons was part of the initial design but might not be fully implemented or utilized in the current backend version focusing on deployment orchestration. Verify current usage if needed.)*

- **Intended Use:** Storing token icons or NFT assets.
- **Provider Recommendation:** Cloud storage (AWS S3, Google Cloud Storage, etc.) is recommended if file uploads are implemented.
- **Access Control:** Public read access for assets, restricted write access for uploads.

---

## 4. API Design Layer

- **Protocol:** REST API built with **FastAPI**.
- **Specification:** The definitive API specification (endpoints, request/response schemas, parameters) is available via the **live, interactive Swagger UI** automatically generated by FastAPI. Access it at the `/docs` endpoint of the running backend service (e.g., `http://localhost:8000/docs`).
- **Key Endpoint Categories:**
    - **Deployment:** (`/api/deploy`, `/api/nft/deploy`) Handles the full workflow for creating, deploying, connecting, and configuring tokens and NFTs.
    - **Verification:** (`/api/verify`, `/api/nft/verify`) Triggers contract verification on block explorers.
    - **Information Retrieval:** (`/api/chains`, `/api/token/{id}`, `/api/nft/collection/{id}`) Provides data about supported chains and specific deployments.
    - **User Assets:** (`/api/users/{address}`) Retrieves comprehensive information about a user's token holdings with balances across all chains.
- **Multi-Chain Balance Retrieval:**
    - The `/api/users/{address}` endpoint queries multiple block explorers to gather token balances.
    - The system supports both Blockscout APIs (used by ZetaChain) and Etherscan-compatible APIs (used by most EVM chains).
    - Balances for Universal Tokens are consolidated across chains to provide a unified view.
    - The implementation automatically identifies Universal Tokens both from the local database and from external explorers.
- **Data Format:** Expects and returns JSON payloads. Uses **snake_case** for field names, consistent with Python conventions.
- **Error Handling:** Uses standard HTTP status codes and returns JSON error responses with a `detail` field for specific error messages or validation issues.
- **Authentication Header:** Requires the `X-Wallet-Address` header for most requests.

---

## 5. Data Security

- **In Transit:** Enforce HTTPS in production deployments.
- **At Rest:** Utilize database-level security features. Store sensitive keys (`DEPLOYER_PRIVATE_KEY`, explorer API keys) securely using environment variables or a dedicated secrets management system. **Never commit secrets to version control.**
- **Sensitive Data:** The primary sensitive piece of data managed by the backend is the `DEPLOYER_PRIVATE_KEY`.
- **Input Validation:** Pydantic models are used for request validation to prevent invalid data injection.

---

## 6. Scalability & Modularity

- **Modular Architecture:** The codebase is organized into distinct layers and modules:
    - **`app/routes/`**: API endpoint definitions.
    - **`app/services/`**: Core business logic:
        - **`deployment.py`**: Token and NFT deployment orchestration.
        - **`verification.py`**: Contract verification on block explorers.
        - **`blockscout.py`**: Interactions with Blockscout API.
        - **`explorer.py`**: Unified interactions with multiple block explorer APIs.
        - **`token.py`**: Token-related business logic.
    - **`app/models/`**: Database models (SQLAlchemy) and API schemas (Pydantic).
    - **`app/utils/`**: Reusable helper functions (Web3 interaction, logging, chain configuration).
    - **`app/db.py` & `app/config.py`**: Database connection and application configuration setup.
- **Asynchronous Operations:** FastAPI runs asynchronously using `async/await`, suitable for I/O-bound tasks like interacting with blockchains and databases.
- **Potential Scaling:** While currently monolithic, the separation allows potential future refactoring into microservices if needed (e.g., separating deployment, verification, and data retrieval).
- **Maintenance:** Follows standard Python best practices (PEP8 via Black/flake8, type hinting) to aid maintainability.

---

## 7. Smart Contract Integration

- **Artifacts:** Contract ABIs and potentially bytecode are expected to be stored in the `/artifacts` directory.
- **Interaction:** The `app/services/deployment.py` and `app/utils/web3_helper.py` modules handle interactions using the `web3.py` library.
- **Key Interactions:**
    - Deploying contracts using `Contract.constructor().transact()`.
    - Calling contract methods (`setConnectedContract`, `setUniversal`, `transfer`, `transferOwnership`) using `Contract.functions.METHOD().transact()`.
    - Estimating gas before transactions.
    - Waiting for transaction receipts.
- **Configuration:** Relies on `rpc_config.json` for chain RPC URLs and crucial addresses like the ZetaChain `gateway_address` on EVM chains.

---

## 8. External API Integration

- **Block Explorer APIs:** The system interacts with multiple block explorer APIs to retrieve token balances and other on-chain data:
    - **Blockscout API:** Used for ZetaChain and other chains that use Blockscout as their explorer.
    - **Etherscan-compatible APIs:** Used for most EVM chains (Etherscan, BscScan, Polygonscan, etc.).
- **Explorer Service:** The `explorer_service` (`app/services/explorer.py`) provides a unified interface for querying different explorer APIs, abstracting away their differences.
- **Configuration:** Explorer URLs are specified in `rpc_config.json` under the `explorer_url` (for Etherscan-compatible APIs) and `blockscout_url` (for Blockscout APIs) fields.
- **API Keys:** Explorer API keys can be configured in the `.env` file for chains that require them.

---

## Summary

- **Framework:** FastAPI (Python 3.11 Required)
- **Database:** PostgreSQL with SQLAlchemy & Alembic
- **Core Logic:** Handles deployment and configuration of Universal Tokens/NFTs across ZetaChain and EVM chains via a service account (`DEPLOYER_PRIVATE_KEY`).
- **API:** RESTful, specified via live `/docs` endpoint, requires `X-Wallet-Address` header.
- **External Integrations:** Multiple block explorer APIs for retrieving token balances across chains.
- **Key Dependencies:** Web3.py, Pydantic, httpx (for HTTP requests to explorer APIs).
- **Configuration:** `.env` for secrets, `rpc_config.json` for chain details.
- **Structure:** Modular design separating routes, services, models, and utilities.
